#
# Developed by Alexandre Novello (PUC-Rio)
#

from unittest import TestCase
import csv
from glamorise_nlidb import GlamoriseNlidb

patterns_json_txt = """{
  "units_of_measurement" : ["cubic meters"],
    "default_pattern" : [{"POS": "ADV", "OP": "*"}, {"POS": "ADJ", "OP": "*"}, {"POS": "NOUN", "LOWER":{"NOT_IN": ["number"]}}],
    "patterns" : {
        "than options" : {
            "reserved_words" : ["more than", "greater than", "less than", "equal to", "greater than or equal to", "less than or equal to"],
            "pre_having_conditions" : [">", ">", "<", "=", ">=", "<="],
            "specific_pattern" : [{"LIKE_NUM": true}, {"POS": "ADV", "OP": "*"}, {"POS": "ADJ", "OP": "*"}, {"POS": "NOUN", "OP": "*"}, {"POS": "NOUN"}],
            "pre_cut_text" : false
        },
        "group by" : {
            "reserved_words" : ["by", "per", "for each", "of each"],
            "pre_group_by" : true,            
            "pre_cut_text" : true
        },
        "group by and" : {
            "reserved_words" : ["by", "per", "for each", "of each"],
            "pre_group_by" : true,
            "specific_pattern" : [{"POS": "ADV", "OP": "*"}, {"POS": "ADJ", "OP": "*"}, {"POS": "NOUN", "LOWER":{"NOT_IN": ["number"]}}, {"LOWER" : "and"}, {"POS": "NOUN", "LOWER":{"NOT_IN": ["number"]}}],
            "pre_cut_text" : false            
        },
        "how options" : {
            "reserved_words" : ["how many", "how much"],
            "pre_aggregation_functions" : ["count", "sum"],
            "pre_cut_text" : true
        },
        "other count" : {
            "reserved_words" : ["number of", "number of the"],
            "pre_aggregation_functions" : "count",
            "pre_cut_text" : true
        },
        "other sum" : {
            "reserved_words" : ["total"],
            "pre_aggregation_functions" : "sum",
            "pre_cut_text" : true
        },      
        "average options" : {
            "reserved_words" : ["average", "avg", "mean"],
            "pre_aggregation_functions" : "avg",
            "pre_cut_text" : true
        },
        "superlative min" : {
            "reserved_words" : ["least", "smallest", "tiniest", "shortest", "cheapest", "nearest", "lowest", "worst", "newest", "min", "minimum"],
            "pre_aggregation_functions" : "min",
            "pre_cut_text" : true
        },
        "superlative max" : {
            "reserved_words" : ["most", "most number of", "biggest", "longest", "furthest", "highest", "tallest", "greatest", "best", "oldest", "max", "maximum"],
            "pre_aggregation_functions" : "max",
            "pre_cut_text" : true
        },
        "time scale options" : {
            "reserved_words" : ["daily", "monthly", "yearly"],
            "pre_time_scale_replace_text" : {"daily" : "day", "monthly" : "month", "yearly" : "year"},
            "pre_time_scale_aggregation_functions" : "sum",
            "pre_cut_text" : false
        }
    }
}"""

class TestGLAMORISE(TestCase):
    def test_GLAMORISE_methods(self):
        # set of questions to test
        with open('./datasets/pfp.csv', encoding="utf-8") as csv_file:
            csv_reader = csv.reader(csv_file, delimiter=';', quotechar="'")
            #jump the title line
            next(csv_reader)
            glamorise = GlamoriseNlidb(patterns = patterns_json_txt)
            for row in csv_reader:
                #the NLQ is the first column of the CSV
                nl_query = row[0]
                glamorise.execute(nl_query)
                try:
                    # assert the NLQ generated by GLAMORISE to the NLIDB is equal to the expected value
                    # (second column of the CSV)
                    assert glamorise.pre_prepared_query.lower() == row[1].lower()
                    print('passed!')
                finally:
                    # print anyway, just for convenience (pytest cuts the string)
                    print('\nPrepared NLQ to NLIDB\nExpected: ', row[1].lower())
                    print('Actual:   ', glamorise.pre_prepared_query.lower())
                try:
                    # assert the SQL generated by GLAMORISE is equal to the expected value
                    # (forth column of the CSV)
                    assert glamorise.pos_glamorise_sql.lower() == row[3].lower()
                    print('passed!')
                finally:
                    # print anyway, just for convenience (pytest cuts the string)
                    print('\nGLAMORISE SQL\nExpected: ', row[3].lower())
                    print('Actual:   ', glamorise.pos_glamorise_sql.lower())
            csv_file.seek(1)
            print('{} NLQ questions tested'.format(sum(1 for line in csv_reader)))
